<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Gabor 分类实验</title>
<style>
    :root {
        color-scheme: light dark;
    }
    * {
        box-sizing: border-box;
    }
    body {
        margin: 0;
        font-family: "Helvetica Neue", Arial, sans-serif;
        background: #d9d9d9;
        color: #111;
        height: 100vh;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #app {
        position: relative;
        width: min(900px, 94vw);
        height: min(94vh, 640px);
        background: rgba(255,255,255,0.94);
        box-shadow: 0 18px 48px rgba(0,0,0,0.18);
        border-radius: 20px;
        padding: clamp(20px, 4vw, 32px);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: clamp(18px, 4vw, 28px);
    }
    h1 {
        margin: 0;
        font-size: clamp(24px, 5vw, 40px);
        text-align: center;
    }
    p {
        margin: 0;
        text-align: center;
        font-size: clamp(16px, 3.8vw, 20px);
        line-height: 1.6;
    }
    label {
        display: block;
        width: 100%;
        text-align: left;
        font-weight: 600;
        margin-bottom: 8px;
    }
    input[type="text"] {
        width: 100%;
        padding: 12px 16px;
        border-radius: 10px;
        border: 1px solid #bbb;
        font-size: 18px;
    }
    button {
        border: none;
        border-radius: 999px;
        padding: 12px 32px;
        font-size: 18px;
        cursor: pointer;
        background: #2f7dff;
        color: #fff;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
    }
    button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 26px rgba(47,125,255,0.35);
        background: #1f5fe0;
    }
    button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
    }
    #startScreen,
    #experimentScreen,
    #finishScreen {
        width: 100%;
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: clamp(20px, 4vw, 32px);
    }
    #canvasHolder {
        position: relative;
        width: min(70vw, 70vh);
        height: min(70vw, 70vh);
        max-width: 500px;
        max-height: 500px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #d9d9d9;
        border-radius: 20px;
        overflow: hidden;
    }
    canvas {
        width: 100%;
        height: 100%;
        display: block;
    }
    #feedbackOverlay,
    #breakOverlay,
    #pauseOverlay {
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: clamp(28px, 6vw, 56px);
        font-weight: 700;
        text-align: center;
        padding: 24px;
        color: #fff;
    }
    #feedbackOverlay.correct {
        display: flex;
        color: #2f9f4f;
    }
    #feedbackOverlay.wrong {
        display: flex;
        color: #d63b3b;
    }
    #breakOverlay,
    #pauseOverlay {
        background: rgba(0,0,0,0.35);
        color: #fff;
        display: none;
        flex-direction: column;
        gap: 16px;
        font-size: clamp(24px, 6vw, 44px);
    }
    #touchZones {
        position: absolute;
        inset: 0;
        display: none;
        pointer-events: none;
    }
    .touchZone {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 50%;
        pointer-events: auto;
    }
    .touchZone.left {
        left: 0;
    }
    .touchZone.right {
        right: 0;
    }
    #startScreen form {
        width: min(420px, 80vw);
        display: flex;
        flex-direction: column;
        gap: 12px;
    }
    #finishScreen button {
        margin-top: 12px;
    }
    @media (max-width: 640px) {
        #app {
            width: 94vw;
            height: 96vh;
            border-radius: 0;
        }
        #canvasHolder {
            width: 68vw;
            height: 68vw;
            max-width: none;
            max-height: none;
            border-radius: 16px;
        }
    }
</style>
</head>
<body>
<div id="app">
    <section id="startScreen">
        <h1>视觉判断任务</h1>
        <p>请输入编号并点击开始。任务中请尽快判断图形属于哪一类。</p>
        <form id="startForm">
            <div>
                <label for="participantInput">被试编号</label>
                <input id="participantInput" type="text" required autocomplete="off" />
            </div>
            <button type="submit" id="startBtn">开始</button>
        </form>
    </section>
    <section id="experimentScreen" hidden>
        <div id="canvasHolder">
            <canvas id="stimulusCanvas"></canvas>
            <div id="feedbackOverlay"></div>
            <div id="breakOverlay"></div>
            <div id="pauseOverlay"></div>
            <div id="touchZones">
                <div class="touchZone left" data-choice="a"></div>
                <div class="touchZone right" data-choice="b"></div>
            </div>
        </div>
    </section>
    <section id="finishScreen" hidden>
        <h1>任务结束</h1>
        <p>感谢参与，请确认数据已保存。</p>
        <button id="downloadBtn">下载数据</button>
    </section>
</div>
<script>
const CFG = Object.freeze({
    LINES_MIN: 4,
    LINES_MAX: 8,
    STRIPE_LEVELS: [4,5,6,7,8],
    ORI_MIN: -15,
    ORI_MAX: 15,
    ORI_BIN_SIZE: 1,
    ORI_JITTER: 0.5,
    RB_TOTAL: 300,
    II_TOTAL: 400,
    RB_ORI_THRESH: 0,
    II_WX: 0.55,
    II_WY: 0.45,
    II_BIAS: 0.0,
    T_DELAY: 2500,
    BREAK_EVERY: 50,
    BREAK_MAX: 20000,
    T_FIX: 500,
    T_PRE: 200,
    T_STIM_MAX: 2000,
    T_FB: 700,
    T_ITI: 600,
    ITI_JITTER: 100
});

const STATE = {
    participant: '',
    session: '',
    delayedMode: false,
    dataRows: [],
    running: false,
    abort: false,
    currentBlock: '',
    currentTrialIndex: 0,
    responseResolver: null,
    responseTimer: null,
    acceptingInput: false,
    backupKey: 'gaborBackup',
    awaitingBreakContinue: null,
    lastFilename: ''
};

const startScreen = document.getElementById('startScreen');
const experimentScreen = document.getElementById('experimentScreen');
const finishScreen = document.getElementById('finishScreen');
const startForm = document.getElementById('startForm');
const participantInput = document.getElementById('participantInput');
const stimulusCanvas = document.getElementById('stimulusCanvas');
const canvasHolder = document.getElementById('canvasHolder');
const feedbackOverlay = document.getElementById('feedbackOverlay');
const breakOverlay = document.getElementById('breakOverlay');
const pauseOverlay = document.getElementById('pauseOverlay');
const touchZones = document.getElementById('touchZones');
const downloadBtn = document.getElementById('downloadBtn');

const ctx = stimulusCanvas.getContext('2d');
let canvasInfo = { cx: 0, cy: 0, diameter: 0, cssDiameter: 0, dpr: 1 };

function updateCanvasSize() {
    const dpr = window.devicePixelRatio || 1;
    const side = Math.min(canvasHolder.clientWidth, canvasHolder.clientHeight);
    const cssDiameter = side * 0.9;
    const pixelDiameter = Math.max(1, Math.round(cssDiameter * dpr));
    stimulusCanvas.width = pixelDiameter;
    stimulusCanvas.height = pixelDiameter;
    stimulusCanvas.style.width = `${Math.round(cssDiameter)}px`;
    stimulusCanvas.style.height = `${Math.round(cssDiameter)}px`;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    canvasInfo = {
        cx: pixelDiameter / 2,
        cy: pixelDiameter / 2,
        diameter: pixelDiameter,
        cssDiameter,
        dpr
    };
    clearCanvas();
}

function clearCanvas() {
    ctx.fillStyle = '#d9d9d9';
    ctx.fillRect(0, 0, canvasInfo.diameter, canvasInfo.diameter);
}

function seededHash(str) {
    let h = 2166136261;
    for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
    }
    return h >>> 0;
}

function makeRNG(seedString) {
    let seed = seededHash(seedString) || 1;
    return function() {
        seed |= 0;
        seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

function shuffleInPlace(arr, rng) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

function getStripeLevels() {
    if (Array.isArray(CFG.STRIPE_LEVELS) && CFG.STRIPE_LEVELS.length) {
        return [...CFG.STRIPE_LEVELS];
    }
    const levels = [];
    for (let n = CFG.LINES_MIN; n <= CFG.LINES_MAX; n++) {
        levels.push(n);
    }
    return levels;
}

function rbLabel(oriDeg, thresh = CFG.RB_ORI_THRESH) {
    return oriDeg >= thresh ? 'B' : 'A';
}

function iiScore(sfLines, oriDeg) {
    const x = (sfLines - 6) / 2;
    const y = oriDeg / 15;
    return CFG.II_WX * x + CFG.II_WY * y + CFG.II_BIAS;
}

function iiLabel(sfLines, oriDeg) {
    return iiScore(sfLines, oriDeg) > 0 ? 'B' : 'A';
}

function jitteredOriForRB(layerDeg, desiredLabel, rng) {
    const minOri = Math.max(CFG.ORI_MIN, layerDeg - CFG.ORI_JITTER);
    const maxOri = Math.min(CFG.ORI_MAX, layerDeg + CFG.ORI_JITTER);
    if (desiredLabel === 'B') {
        const minTarget = Math.max(minOri, CFG.RB_ORI_THRESH);
        const range = Math.max(0, maxOri - minTarget);
        return range === 0 ? minTarget : minTarget + rng() * range;
    }
    const maxTarget = Math.min(maxOri, CFG.RB_ORI_THRESH - 1e-4);
    const range = Math.max(0, maxTarget - minOri);
    return range === 0 ? maxTarget : minOri + rng() * range;
}

function jitteredOriForII(layerDeg, sfLines, desiredLabel, rng) {
    const minOri = Math.max(CFG.ORI_MIN, layerDeg - CFG.ORI_JITTER);
    const maxOri = Math.min(CFG.ORI_MAX, layerDeg + CFG.ORI_JITTER);
    for (let attempt = 0; attempt < 12; attempt++) {
        const candidate = minOri + (maxOri - minOri) * rng();
        if (iiLabel(sfLines, candidate) === desiredLabel) {
            return candidate;
        }
    }
    if (CFG.II_WY !== 0) {
        const x = (sfLines - 6) / 2;
        const yBoundary = -(CFG.II_WX * x + CFG.II_BIAS) / CFG.II_WY;
        const oriBoundary = Math.max(CFG.ORI_MIN, Math.min(CFG.ORI_MAX, yBoundary * 15));
        const epsilon = 0.05;
        let candidate = desiredLabel === 'B' ? oriBoundary + epsilon : oriBoundary - epsilon;
        candidate = Math.max(minOri, Math.min(maxOri, candidate));
        if (iiLabel(sfLines, candidate) === desiredLabel) {
            return candidate;
        }
    }
    return desiredLabel === 'B' ? maxOri : minOri;
}

function makeTrialsRB(participant) {
    const rng = makeRNG(`${participant}-RB`);
    const stripes = getStripeLevels();
    const layers = [];
    for (let deg = CFG.ORI_MIN; deg <= CFG.ORI_MAX; deg += CFG.ORI_BIN_SIZE) {
        layers.push(deg);
    }
    const negLayers = layers.filter(v => v < CFG.RB_ORI_THRESH);
    const posLayers = layers.filter(v => v >= CFG.RB_ORI_THRESH);
    const counts = new Map();

    function assignCounts(layerSet, totalTarget) {
        const base = Math.floor(totalTarget / layerSet.length);
        let remainder = totalTarget - base * layerSet.length;
        const shuffled = shuffleInPlace([...layerSet], makeRNG(`spread-${participant}-${layerSet.length}-${totalTarget}`));
        shuffled.forEach(layer => {
            const extra = remainder > 0 ? 1 : 0;
            if (remainder > 0) remainder--;
            counts.set(layer, (counts.get(layer) || 0) + base + extra);
        });
    }

    assignCounts(negLayers, CFG.RB_TOTAL / 2);
    assignCounts(posLayers, CFG.RB_TOTAL / 2);

    const trials = [];
    for (const layer of layers) {
        const desiredLabel = layer >= CFG.RB_ORI_THRESH ? 'B' : 'A';
        const count = counts.get(layer) || 0;
        for (let i = 0; i < count; i++) {
            const sf = stripes[Math.floor(rng() * stripes.length)];
            const ori = jitteredOriForRB(layer, desiredLabel, rng);
            const label = rbLabel(ori);
            trials.push({ blockName: 'RB', sfLines: sf, oriDeg: ori, label, correctKey: label === 'A' ? 'a' : 'b' });
        }
    }
    shuffleInPlace(trials, rng);
    return trials;
}

function comboCanYieldLabel(layerDeg, sfLines, desiredLabel) {
    const testRng = makeRNG(`${layerDeg}-${sfLines}-${desiredLabel}`);
    const ori = jitteredOriForII(layerDeg, sfLines, desiredLabel, testRng);
    return iiLabel(sfLines, ori) === desiredLabel;
}

function makeTrialsII(participant) {
    const rng = makeRNG(`${participant}-II`);
    const stripes = getStripeLevels();
    const layers = [];
    for (let deg = CFG.ORI_MIN; deg <= CFG.ORI_MAX; deg += CFG.ORI_BIN_SIZE) {
        layers.push(deg);
    }
    const combos = [];
    for (const layer of layers) {
        for (const sf of stripes) {
            const baseScore = iiScore(sf, layer);
            const baseLabel = baseScore > 0 ? 'B' : 'A';
            const absScore = Math.abs(baseScore);
            combos.push({ layer, sf, baseLabel, absScore });
        }
    }
    const remaining = { 'A': CFG.II_TOTAL / 2, 'B': CFG.II_TOTAL / 2 };
    const trials = [];
    const shuffledCombos = shuffleInPlace([...combos], rng);

    for (const combo of shuffledCombos) {
        if (trials.length >= CFG.II_TOTAL) break;
        const preferLabel = remaining['A'] > remaining['B'] ? 'A' : 'B';
        let targetLabel = preferLabel;
        if (!comboCanYieldLabel(combo.layer, combo.sf, targetLabel)) {
            const fallback = targetLabel === 'A' ? 'B' : 'A';
            if (comboCanYieldLabel(combo.layer, combo.sf, fallback)) {
                targetLabel = fallback;
            }
        }
        const ori = jitteredOriForII(combo.layer, combo.sf, targetLabel, rng);
        const label = iiLabel(combo.sf, ori);
        trials.push({ blockName: 'II', sfLines: combo.sf, oriDeg: ori, label, correctKey: label === 'A' ? 'a' : 'b', score: iiScore(combo.sf, ori) });
        remaining[label] = Math.max(0, remaining[label] - 1);
    }

    const needMore = CFG.II_TOTAL - trials.length;
    if (needMore > 0) {
        const byLabel = { 'A': [], 'B': [] };
        for (const combo of combos) {
            if (comboCanYieldLabel(combo.layer, combo.sf, 'A')) {
                byLabel['A'].push(combo);
            }
            if (comboCanYieldLabel(combo.layer, combo.sf, 'B')) {
                byLabel['B'].push(combo);
            }
        }
        byLabel['A'].sort((a, b) => a.absScore - b.absScore);
        byLabel['B'].sort((a, b) => a.absScore - b.absScore);
        const indices = { 'A': 0, 'B': 0 };
        while (trials.length < CFG.II_TOTAL) {
            let labelNeeded = remaining['A'] > remaining['B'] ? 'A' : 'B';
            let pool = byLabel[labelNeeded];
            if (!pool.length) {
                labelNeeded = labelNeeded === 'A' ? 'B' : 'A';
                pool = byLabel[labelNeeded];
            }
            if (!pool.length) break;
            const combo = pool[indices[labelNeeded] % pool.length];
            indices[labelNeeded]++;
            const ori = jitteredOriForII(combo.layer, combo.sf, labelNeeded, rng);
            const label = iiLabel(combo.sf, ori);
            trials.push({ blockName: 'II', sfLines: combo.sf, oriDeg: ori, label, correctKey: label === 'A' ? 'a' : 'b', score: iiScore(combo.sf, ori) });
            remaining[label] = Math.max(0, remaining[label] - 1);
        }
    }

    shuffleInPlace(trials, rng);

    const countA = trials.filter(t => t.label === 'A').length;
    const countB = trials.length - countA;
    const diff = countA - countB;
    if (Math.abs(diff) > 1) {
        const majority = diff > 0 ? 'A' : 'B';
        const minority = majority === 'A' ? 'B' : 'A';
        const sorted = trials
            .map((trial, idx) => ({ trial, idx }))
            .filter(item => item.trial.label === majority)
            .sort((a, b) => Math.abs(a.trial.score) - Math.abs(b.trial.score));
        for (const item of sorted) {
            if (Math.abs(trials.filter(t => t.label === 'A').length - trials.filter(t => t.label === 'B').length) <= 1) break;
            const combo = { layer: Math.round(item.trial.oriDeg), sf: item.trial.sfLines, absScore: Math.abs(item.trial.score) };
            const newOri = jitteredOriForII(combo.layer, combo.sf, minority, rng);
            const newLabel = iiLabel(combo.sf, newOri);
            if (newLabel !== minority) continue;
            trials[item.idx] = { blockName: 'II', sfLines: combo.sf, oriDeg: newOri, label: newLabel, correctKey: newLabel === 'A' ? 'a' : 'b', score: iiScore(combo.sf, newOri) };
        }
    }

    return trials.map(({ score, ...rest }) => rest);
}

function insertBreaks(trials) {
    const withBreaks = [];
    let trialCounter = 0;
    for (const trial of trials) {
        withBreaks.push({ type: 'trial', ...trial });
        trialCounter++;
        if (trialCounter % CFG.BREAK_EVERY === 0 && trialCounter < trials.length) {
            withBreaks.push({ type: 'break' });
        }
    }
    return withBreaks;
}

function drawFixation() {
    clearCanvas();
    const { cx, cy } = canvasInfo;
    const arm = canvasInfo.diameter * 0.08;
    ctx.strokeStyle = '#000';
    ctx.lineWidth = Math.max(2, canvasInfo.diameter * 0.01);
    ctx.beginPath();
    ctx.moveTo(cx - arm, cy);
    ctx.lineTo(cx + arm, cy);
    ctx.moveTo(cx, cy - arm);
    ctx.lineTo(cx, cy + arm);
    ctx.stroke();
}

function drawBlank() {
    clearCanvas();
}

function drawGabor(ctx, cx, cy, diameterPx, oriDeg, sfLines) {
    const cycles = sfLines / 2; // 直径方向上 sfLines 条黑白条纹 → 周期数 cycles
    const radius = diameterPx / 2;
    const size = Math.ceil(diameterPx);
    const startX = Math.round(cx - radius);
    const startY = Math.round(cy - radius);
    const imageData = ctx.createImageData(size, size);
    const data = imageData.data;
    const oriRad = oriDeg * Math.PI / 180;
    const cos = Math.cos(oriRad);
    const sin = Math.sin(oriRad);

    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const relX = x - size / 2;
            const relY = y - size / 2;
            const dist = Math.sqrt(relX * relX + relY * relY);
            const idx = (y * size + x) * 4;
            if (dist <= radius) {
                const rot = relX * cos + relY * sin;
                const phase = (rot / diameterPx) * cycles * 2 * Math.PI;
                const value = 0.5 + 0.5 * Math.sin(phase);
                const gray = Math.round(value * 255);
                data[idx] = gray;
                data[idx + 1] = gray;
                data[idx + 2] = gray;
                data[idx + 3] = 255;
            } else {
                data[idx] = 217;
                data[idx + 1] = 217;
                data[idx + 2] = 217;
                data[idx + 3] = 255;
            }
        }
    }
    ctx.putImageData(imageData, startX, startY);
    ctx.save();
    ctx.strokeStyle = '#000';
    ctx.lineWidth = Math.max(2, diameterPx * 0.012);
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
}

function renderStimulus(sfLines, oriDeg) {
    drawBlank();
    drawGabor(ctx, canvasInfo.cx, canvasInfo.cy, canvasInfo.diameter, oriDeg, sfLines);
}

function hideFeedback() {
    feedbackOverlay.className = '';
    feedbackOverlay.textContent = '';
}

function showFeedback(correct) {
    feedbackOverlay.textContent = correct ? 'Correct' : 'Wrong';
    feedbackOverlay.className = correct ? 'correct' : 'wrong';
}

function showBreakOverlay(remainingMs) {
    breakOverlay.style.display = 'flex';
    breakOverlay.innerHTML = `<div>休息一下</div><div style="font-size:0.6em">空格继续 · ${Math.ceil(remainingMs/1000)}s</div>`;
}

function hideBreakOverlay() {
    breakOverlay.style.display = 'none';
    breakOverlay.textContent = '';
}

function showPauseOverlay(message) {
    pauseOverlay.style.display = 'flex';
    pauseOverlay.textContent = message;
}

function hidePauseOverlay() {
    pauseOverlay.style.display = 'none';
    pauseOverlay.textContent = '';
}

function wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

let gamepadLoop = null;
const gamepadState = { left: false, right: false };

function buttonPressed(button) {
    if (!button) return false;
    if (typeof button === 'object') {
        return button.pressed;
    }
    return button === 1;
}

function pollGamepads() {
    const pads = navigator.getGamepads ? navigator.getGamepads() : [];
    let leftActive = false;
    let rightActive = false;
    for (const pad of pads) {
        if (!pad) continue;
        const buttons = pad.buttons || [];
        const axes = pad.axes || [];
        const left = buttonPressed(buttons[14]) || buttonPressed(buttons[0]) || (axes[0] !== undefined && axes[0] < -0.5);
        const right = buttonPressed(buttons[15]) || buttonPressed(buttons[1]) || (axes[0] !== undefined && axes[0] > 0.5);
        leftActive = leftActive || left;
        rightActive = rightActive || right;
    }
    if (leftActive && !gamepadState.left) {
        registerResponse('a');
    }
    if (rightActive && !gamepadState.right) {
        registerResponse('b');
    }
    gamepadState.left = leftActive;
    gamepadState.right = rightActive;
    gamepadLoop = requestAnimationFrame(pollGamepads);
}

function startGamepadLoop() {
    if (gamepadLoop !== null) return;
    gamepadLoop = requestAnimationFrame(pollGamepads);
}

function stopGamepadLoop() {
    if (gamepadLoop !== null) {
        cancelAnimationFrame(gamepadLoop);
        gamepadLoop = null;
    }
    gamepadState.left = false;
    gamepadState.right = false;
}

function setupInputListeners() {
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('pointerdown', handlePointerDown);
    window.addEventListener('resize', updateCanvasSize);
    window.addEventListener('beforeunload', handleBeforeUnload);
    startGamepadLoop();
}

function removeInputListeners() {
    document.removeEventListener('keydown', handleKeyDown);
    document.removeEventListener('pointerdown', handlePointerDown);
    window.removeEventListener('resize', updateCanvasSize);
    window.removeEventListener('beforeunload', handleBeforeUnload);
    stopGamepadLoop();
}

function handlePointerDown(event) {
    if (!STATE.acceptingInput) return;
    const x = event.clientX;
    const isLeft = x < window.innerWidth / 2;
    registerResponse(isLeft ? 'a' : 'b');
}

function mapKeyToResponse(event) {
    const key = event.key.toLowerCase();
    if (key === 'a' || key === 'arrowleft') return 'a';
    if (key === 'b' || key === 'arrowright') return 'b';
    return null;
}

function handleKeyDown(event) {
    if (event.key === 'Escape') {
        event.preventDefault();
        abortExperiment();
        return;
    }
    if (STATE.awaitingBreakContinue && event.code === 'Space') {
        event.preventDefault();
        const resolver = STATE.awaitingBreakContinue;
        STATE.awaitingBreakContinue = null;
        resolver(false);
        return;
    }
    if (!STATE.acceptingInput) return;
    const mapped = mapKeyToResponse(event);
    if (mapped) {
        event.preventDefault();
        registerResponse(mapped);
    }
}

function registerResponse(key) {
    if (!STATE.acceptingInput || !STATE.responseResolver) return;
    STATE.acceptingInput = false;
    if (STATE.responseTimer) {
        clearTimeout(STATE.responseTimer);
        STATE.responseTimer = null;
    }
    STATE.responseResolver({ key, timeout: false });
    STATE.responseResolver = null;
}

function waitForResponse(limitMs, startTime) {
    return new Promise(resolve => {
        STATE.acceptingInput = true;
        STATE.responseResolver = resolve;
        STATE.responseTimer = setTimeout(() => {
            STATE.acceptingInput = false;
            STATE.responseResolver = null;
            resolve({ key: 'NA', timeout: true });
        }, limitMs);
    });
}

async function runBreak() {
    hideFeedback();
    drawBlank();
    let elapsed = 0;
    const interval = 250;
    let resolver;
    const promise = new Promise(resolve => {
        resolver = resolve;
    });
    STATE.awaitingBreakContinue = resolver;
    const start = performance.now();
    const tick = () => {
        const remaining = Math.max(0, CFG.BREAK_MAX - elapsed);
        showBreakOverlay(remaining);
        if (remaining <= 0) {
            if (STATE.awaitingBreakContinue) {
                STATE.awaitingBreakContinue(false);
                STATE.awaitingBreakContinue = null;
            }
            return;
        }
        if (!STATE.awaitingBreakContinue) return;
        setTimeout(() => {
            elapsed = performance.now() - start;
            tick();
        }, interval);
    };
    tick();
    await Promise.race([
        promise,
        wait(CFG.BREAK_MAX).then(() => true)
    ]);
    STATE.awaitingBreakContinue = null;
    hideBreakOverlay();
}

async function runTrial(trial, index) {
    hideFeedback();
    drawFixation();
    const trialStartUTC = new Date().toISOString();
    await wait(CFG.T_FIX);
    drawBlank();
    await wait(CFG.T_PRE);
    if (STATE.delayedMode) {
        drawBlank();
        await wait(CFG.T_DELAY);
    }
    const stimStart = performance.now();
    renderStimulus(trial.sfLines, trial.oriDeg);
    const responsePromise = waitForResponse(CFG.T_STIM_MAX, stimStart);
    const response = await responsePromise;
    const rt = response.timeout ? '' : ((performance.now() - stimStart) / 1000).toFixed(3);
    drawBlank();
    if (STATE.abort) {
        return;
    }
    const correct = response.key === trial.correctKey;
    const corrFlag = response.timeout ? 0 : (correct ? 1 : 0);
    if (response.timeout) {
        showFeedback(false);
    } else {
        showFeedback(correct);
    }
    await wait(CFG.T_FB);
    hideFeedback();
    drawBlank();
    const jitter = CFG.ITI_JITTER > 0 ? (CFG.ITI_JITTER * (Math.random() * 2 - 1)) : 0;
    await wait(Math.max(0, CFG.T_ITI + jitter));

    const row = {
        participant: STATE.participant,
        session: STATE.session,
        blockName: trial.blockName,
        trialIndex: index,
        sf: trial.sfLines,
        ori: Number(trial.oriDeg.toFixed(3)),
        label: trial.label,
        correctKey: trial.correctKey,
        resp: response.key,
        corr: response.timeout ? 0 : (correct ? 1 : 0),
        rt: rt,
        timeout: response.timeout ? 1 : 0,
        trialStartUTC
    };
    STATE.dataRows.push(row);
    persistBackup();
}

function persistBackup() {
    try {
        const payload = {
            participant: STATE.participant,
            session: STATE.session,
            rows: STATE.dataRows
        };
        localStorage.setItem(STATE.backupKey, JSON.stringify(payload));
    } catch (err) {
        console.warn('无法写入本地备份', err);
    }
}

function buildCSV(rows) {
    const headers = ['participant','session','blockName','trialIndex','sf','ori','label','correctKey','resp','corr','rt','timeout','trialStartUTC'];
    const lines = [headers.join(',')];
    for (const row of rows) {
        const values = headers.map(key => {
            const value = row[key] ?? '';
            if (typeof value === 'string' && value.includes(',')) {
                return `"${value.replace(/"/g, '""')}"`;
            }
            return value;
        });
        lines.push(values.join(','));
    }
    return lines.join('\n');
}

function downloadCSV(filename, rows) {
    if (!rows.length) return;
    const csv = buildCSV(rows);
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(() => URL.revokeObjectURL(url), 1000);
}

function handleBeforeUnload(event) {
    if (!STATE.dataRows.length) return;
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `gabor_${STATE.participant || 'session'}_${timestamp}.csv`;
    downloadCSV(filename, STATE.dataRows);
}

function abortExperiment() {
    if (!STATE.running) return;
    STATE.abort = true;
    STATE.acceptingInput = false;
    if (STATE.responseResolver) {
        STATE.responseResolver({ key: 'NA', timeout: true });
        STATE.responseResolver = null;
    }
    if (STATE.responseTimer) {
        clearTimeout(STATE.responseTimer);
        STATE.responseTimer = null;
    }
    endExperiment();
}

async function runBlock(blockName, baseTrials) {
    STATE.currentBlock = blockName;
    STATE.currentTrialIndex = 0;
    const queue = insertBreaks(baseTrials);
    for (const item of queue) {
        if (STATE.abort) break;
        if (item.type === 'break') {
            await runBreak();
            continue;
        }
        STATE.currentTrialIndex++;
        await runTrial(item, STATE.currentTrialIndex);
    }
}

async function runExperiment() {
    STATE.running = true;
    const rbTrials = makeTrialsRB(STATE.participant);
    const iiTrials = makeTrialsII(STATE.participant);
    await runBlock('RB', rbTrials);
    if (!STATE.abort) {
        await runBlock('II', iiTrials);
    }
    endExperiment();
}

function endExperiment() {
    if (!finishScreen.hidden) {
        return;
    }
    STATE.running = false;
    removeInputListeners();
    hideFeedback();
    hideBreakOverlay();
    hidePauseOverlay();
    drawBlank();
    experimentScreen.hidden = true;
    finishScreen.hidden = false;
    touchZones.style.display = 'none';
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `gabor_${STATE.participant || 'session'}_${timestamp}.csv`;
    STATE.lastFilename = filename;
    downloadCSV(filename, STATE.dataRows);
}

async function requestFullscreen() {
    if (document.fullscreenElement) return;
    try {
        if (document.documentElement.requestFullscreen) {
            await document.documentElement.requestFullscreen();
        }
    } catch (err) {
        console.warn('无法全屏', err);
    }
}

startForm.addEventListener('submit', async (event) => {
    event.preventDefault();
    const participant = participantInput.value.trim();
    if (!participant) return;
    STATE.participant = participant;
    STATE.session = new Date().toISOString();
    STATE.delayedMode = /^[A-Za-z]/.test(participant);
    startScreen.hidden = true;
    finishScreen.hidden = true;
    experimentScreen.hidden = false;
    touchZones.style.display = 'block';
    updateCanvasSize();
    setupInputListeners();
    await requestFullscreen();
    STATE.abort = false;
    STATE.dataRows = [];
    STATE.lastFilename = '';
    persistBackup();
    runExperiment();
});

downloadBtn.addEventListener('click', () => {
    if (!STATE.dataRows.length) return;
    const filename = STATE.lastFilename || `gabor_${STATE.participant || 'session'}_${Date.now()}.csv`;
    downloadCSV(filename, STATE.dataRows);
});

updateCanvasSize();
</script>
</body>
</html>
